// This is free and unencumbered software released into the public
// domain.  For more information, see <http://unlicense.org> or the
// accompanying UNLICENSE file.

//go:generate hel

package mock

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"os"
	"slices"
	"strconv"

	"git.sr.ht/~nelsam/hel/console"
	"git.sr.ht/~nelsam/hel/dep"
	"git.sr.ht/~nelsam/hel/typ"
	"git.sr.ht/~nelsam/hel/vegr"
)

const commentHeader = `// Code generated by git.sr.ht/~nelsam/hel. DO NOT EDIT.
//
// This file contains mocks generated by hel. Do not edit this code by
// hand unless you *really* know what you're doing. Expect any changes
// made manually to be overwritten the next time hel regenerates this
// file.

`

// TypeFinder represents a type which knows about types and dependencies.
type TypeFinder interface {
	Decls(context.Context) []ast.Decl
	Dependencies(ctx context.Context, name string) []typ.Dependency
}

type import_ struct {
	name string
	path string
}

func (i import_) ident() *ast.Ident {
	if i.name == "" {
		return nil
	}
	return &ast.Ident{Name: i.name}
}

func (i import_) ast() *ast.ImportSpec {
	return &ast.ImportSpec{
		Name: i.ident(),
		Path: &ast.BasicLit{Kind: token.STRING, Value: strconv.Quote(i.path)},
	}
}

// Mocks is a set of mocks generated from a go package.
type Mocks struct {
	imports []import_
	mocks   []Mock
}

// Output writes the go code representing m to dest.  pkg will be the
// package name; dir is the destination directory (needed for formatting
// the file); chanSize is the buffer size of any channels created in
// constructors.
func (m *Mocks) Output(ctx context.Context, pkg, dir string, chanSize int, dest io.Writer) error {
	if _, err := dest.Write([]byte(commentHeader)); err != nil {
		return fmt.Errorf("mock: failed to write comment header: %w", err)
	}

	fset := token.NewFileSet()

	imps := []ast.Spec{
		&ast.ImportSpec{Path: &ast.BasicLit{Kind: token.STRING, Value: `"time"`}},
		&ast.ImportSpec{Path: &ast.BasicLit{Kind: token.STRING, Value: `"git.sr.ht/~nelsam/hel/vegr"`}},
		&ast.ImportSpec{Path: &ast.BasicLit{Kind: token.STRING, Value: `"git.sr.ht/~nelsam/hel/vegr/ret"`}},
	}
	for _, i := range m.imports {
		imps = append(imps, i.ast())
	}
	impDecl := &ast.GenDecl{Tok: token.IMPORT, Specs: imps}

	versionDecl := &ast.GenDecl{
		Tok: token.VAR,
		Specs: []ast.Spec{
			&ast.ValueSpec{
				Names: []*ast.Ident{{Name: "_"}},
				Values: []ast.Expr{&ast.CallExpr{
					Fun: &ast.SelectorExpr{
						X:   &ast.Ident{Name: "vegr"},
						Sel: &ast.Ident{Name: "EnforceVersion"},
					},
					Args: []ast.Expr{&ast.BinaryExpr{
						X:  &ast.BasicLit{Kind: token.INT, Value: strconv.Itoa(vegr.Version)},
						Op: token.SUB,
						Y:  &ast.SelectorExpr{X: &ast.Ident{Name: "vegr"}, Sel: &ast.Ident{Name: "MinVersion"}},
					}},
				}},
			},
			&ast.ValueSpec{
				Names: []*ast.Ident{{Name: "_"}},
				Values: []ast.Expr{&ast.CallExpr{
					Fun: &ast.SelectorExpr{
						X:   &ast.Ident{Name: "vegr"},
						Sel: &ast.Ident{Name: "EnforceVersion"},
					},
					Args: []ast.Expr{&ast.BinaryExpr{
						X:  &ast.SelectorExpr{X: &ast.Ident{Name: "vegr"}, Sel: &ast.Ident{Name: "MaxVersion"}},
						Op: token.SUB,
						Y:  &ast.BasicLit{Kind: token.INT, Value: strconv.Itoa(vegr.Version)},
					}},
				}},
			},
		},
	}

	decls := []ast.Decl{impDecl, versionDecl}
	f := &ast.File{
		Name:  &ast.Ident{Name: pkg},
		Decls: append(decls, m.decls(ctx, chanSize)...),
	}

	var b bytes.Buffer
	if err := format.Node(&b, fset, f); err != nil {
		return fmt.Errorf("mock: failed to run initial formatting pass: %w", err)
	}

	fset = token.NewFileSet()
	file, err := parser.ParseFile(fset, pkg, &b, 0)
	if err != nil {
		out, tmpErr := os.CreateTemp("", "*.go")
		if tmpErr != nil {
			return fmt.Errorf("mock: failed to parse formatted code [could not save output for debugging]: %w", err)
		}
		out.WriteString(b.String())
		return fmt.Errorf("mock: failed to parse formatted code [saved for debugging as %v]: %w", out.Name(), err)
	}

	if err := format.Node(dest, fset, file); err != nil {
		return fmt.Errorf("mock: failed to run final formatting pass to file: %w", err)
	}
	return nil
}

// PrependLocalPackage prepends name as the package name for local types
// in m's signature.  This is most often used when mocking types that are
// imported by the local package.
func (m *Mocks) PrependLocalPackage(ctx context.Context, name string) {
	for i := 0; i < len(m.mocks); i++ {
		mock := m.mocks[i]
		if err := mock.PrependLocalPackage(ctx, name); err != nil {
			fmt.Printf("\nWARN: type %v could not prepend package selector, mocks will not be generated: %v\n", mock.Name(ctx), err)
			m.mocks = append(m.mocks[:i], m.mocks[i+1:]...)
			i--
		}
	}
}

func (m *Mocks) decls(ctx context.Context, chanSize int) (decls []ast.Decl) {
	for _, mock := range m.mocks {
		decls = append(decls, mock.Ast(ctx, chanSize)...)
	}
	return decls
}

func (m *Mocks) Len(ctx context.Context) int {
	return len(m.mocks)
}

func (m *Mocks) Index(ctx context.Context, i int) Mock {
	return m.mocks[i]
}

func (m *Mocks) addImport(ctx context.Context, name, path string) error {
	for _, i := range m.imports {
		if i.path != path {
			continue
		}
		if i.name != name {
			return fmt.Errorf("mock: cannot generate mocks: conflicting names %v and %v for import %v", name, i.name, path)
		}
		return nil
	}
	m.imports = append(m.imports, import_{
		name: name,
		path: path,
	})
	return nil
}

type genMode int

const (
	modeLocalInterfaces = 1 << iota
	modeConcreteDeps

	modeAll = modeLocalInterfaces | modeConcreteDeps
)

type genPrefs struct {
	mode genMode
}

// Opt is an option function that can apply preferences for generating mocks.
type Opt func(genPrefs) genPrefs

// ForLocalInterfaces tells Generate to generate mocks for local interface
// types.
//
// If none of the For* options are included, the default will be to generate
// mocks for all strategies.
func ForLocalInterfaces() Opt {
	return func(p genPrefs) genPrefs {
		p.mode |= modeLocalInterfaces
		return p
	}
}

// ForConcreteDependencies tells Generate to generate mocks for any interface
// types that are depended on by functions, methods, or struct fields in
// exported code.
//
// If none of the For* options are included, the default will be to generate
// mocks for all strategies.
func ForConcreteDependencies() Opt {
	return func(p genPrefs) genPrefs {
		p.mode |= modeConcreteDeps
		return p
	}
}

// Generate generates a Mocks value for all interface types that are required,
// according to finder.
func Generate(ctx context.Context, finder TypeFinder, opts ...Opt) (*Mocks, error) {
	var prefs genPrefs
	for _, o := range opts {
		prefs = o(prefs)
	}
	if prefs.mode == 0 {
		prefs.mode = modeAll
	}
	base := finder.Decls(ctx)
	var (
		typs []*ast.TypeSpec
		deps []typ.Dependency
	)
	cons := console.FromCtx(ctx)
	for _, typ := range base {
		switch typ := typ.(type) {
		case *ast.GenDecl:
			for _, spec := range typ.Specs {
				specCtx := ctx
				switch spec := spec.(type) {
				case *ast.TypeSpec:
					switch spec.Type.(type) {
					case *ast.InterfaceType:
						if prefs.mode&modeLocalInterfaces == 0 {
							continue
						}
						cons.Print("%s [local interface type]", console.Fmt(spec.Name.Name), console.AsVerbose())
						specCtx = cons.WithPrefix("- ").Ctx(ctx)
						typs = append(typs, spec)
					case *ast.StructType:
						if prefs.mode&modeConcreteDeps == 0 {
							continue
						}
						cons.Print("%s [local struct type]", console.Fmt(spec.Name.Name), console.AsVerbose())
						specCtx = cons.WithPrefix("- ").Ctx(ctx)
					}
					deps = append(deps, finder.Dependencies(specCtx, spec.Name.Name)...)
				}
			}
		case *ast.FuncDecl:
			if prefs.mode&modeConcreteDeps == 0 {
				continue
			}
			cons.Print("%s [local function]", console.Fmt(typ.Name.Name), console.AsVerbose())
			deps = append(deps, finder.Dependencies(cons.WithPrefix("- ").Ctx(ctx), typ.Name.Name)...)
		}
	}
	deps = deDupe(ctx, typs, deps)
	var m Mocks
	for _, dep := range deps {
		pkgName := dep.PkgName()
		if !dep.ImportAliased() {
			pkgName = ""
		}
		if dep.PkgPath() != "" {
			if err := m.addImport(ctx, pkgName, dep.PkgPath()); err != nil {
				return nil, fmt.Errorf("mock: failed to generate dependency mock %v: %w", dep.Name(), err)
			}
		}
		inter, ok := dep.Type().(*ast.InterfaceType)
		if !ok {
			continue
		}
		newMock, err := For(ctx, dep.TypeName(), dep.Params(), inter)
		if errors.Is(err, ErrUnexported) {
			fmt.Printf("\nWARN: could not generate a mock for dependency type %v: %v\n", dep.Name(), err)
			continue
		}
		if err != nil {
			return nil, fmt.Errorf("mock: failed to generate dependency mock %v: %w", dep.Name(), err)
		}
		if dep.PkgPath() == "" {
			// This is a local type, so no extra work needs to be done with the
			// package selector.
			m.mocks = append(m.mocks, newMock)
			continue
		}
		selectorErr := newMock.PrependLocalPackage(ctx, dep.PkgName())
		if errors.Is(selectorErr, ErrUnexported) {
			fmt.Printf("\nWARN: could not generate a mock for dependency type %v: type signature contains unexported types: %v\n", dep.Name(), selectorErr)
			continue
		}
		if selectorErr != nil {
			return nil, fmt.Errorf("mock: failed to add package selector to dependency mock %v: %w", dep.Name(), selectorErr)
		}
		m.mocks = append(m.mocks, newMock)
	}
	return &m, nil
}

func deDupe(ctx context.Context, typs []*ast.TypeSpec, deps []typ.Dependency) []typ.Dependency {
	var local []typ.Dependency
	for _, t := range typs {
		var opts []dep.Opt
		if t.TypeParams != nil {
			opts = append(opts, dep.WithTypeParams(t.TypeParams.List...))
		}
		local = append(local, dep.New(ctx, t.Name, t.Type, opts...))
	}
	for _, d := range deps {
		// dependencies on local types get first choice of name; non-local types
		// get deduped.
		if d.PkgPath() != "" {
			continue
		}
		if slices.ContainsFunc(local, func(exists typ.Dependency) bool { return exists.Name() == d.Name() }) {
			continue
		}
		local = append(local, d)
	}

	all := local
	for _, d := range deps {
		if d.PkgPath() == "" {
			// We've already dealt with local types.
			continue
		}
		for slices.ContainsFunc(local, func(exists typ.Dependency) bool { return exists.TypeName() == d.TypeName() }) {
			d = d.AvoidCollision(ctx)
		}
		all = append(all, d)
	}
	for i := 0; i < len(all); i++ {
		for j := i + 1; j < len(all); j++ {
			if equal(all[i], all[j]) {
				all = append(all[:j], all[j+1:]...)
				j--
				continue
			}
			for all[i].TypeName() == all[j].TypeName() {
				all[j] = all[j].AvoidCollision(ctx)
			}
		}
	}
	return all
}

func equal(a, b typ.Dependency) bool {
	if a.PkgPath() != b.PkgPath() {
		return false
	}
	if a.TypeName() != b.TypeName() {
		return false
	}
	return true
}

// Code generated by git.sr.ht/~nelsam/hel. DO NOT EDIT.
//
// This file contains mocks generated by hel. Do not edit this code by
// hand unless you *really* know what you're doing. Expect any changes
// made manually to be overwritten the next time hel regenerates this
// file.

package bindings_test

import (
	"net"
	"time"

	"git.sr.ht/~nelsam/hel/vegr"
)

var (
	_ = vegr.EnforceVersion(7 - vegr.MinVersion)
	_ = vegr.EnforceVersion(vegr.MaxVersion - 7)
)

type mockIPChecker_ResolveAddr_In struct {
	Host string
}
type mockIPChecker_ResolveAddr_Out struct {
	Panic_ any
	Ret0   net.IP
	Ret1   error
}
type mockIPChecker_ResolveAddr struct {
	vegr.Method[mockIPChecker_ResolveAddr_In, mockIPChecker_ResolveAddr_Out]
}
type mockIPChecker_CheckBlacklist_In struct {
	Ip net.IP
}
type mockIPChecker_CheckBlacklist_Out struct {
	Panic_ any
	Ret0   error
}
type mockIPChecker_CheckBlacklist struct {
	vegr.Method[mockIPChecker_CheckBlacklist_In, mockIPChecker_CheckBlacklist_Out]
}
type mockIPChecker struct {
	t       vegr.TestingT
	timeout time.Duration
	method  struct {
		ResolveAddr    mockIPChecker_ResolveAddr
		CheckBlacklist mockIPChecker_CheckBlacklist
	}
}

func newMockIPChecker(t vegr.TestingT, timeout time.Duration) *mockIPChecker {
	m := &mockIPChecker{t: t, timeout: timeout}
	m.method.ResolveAddr.Method = vegr.NewMethod[mockIPChecker_ResolveAddr_In, mockIPChecker_ResolveAddr_Out]("mockIPChecker", "ResolveAddr", 100)
	m.method.CheckBlacklist.Method = vegr.NewMethod[mockIPChecker_CheckBlacklist_In, mockIPChecker_CheckBlacklist_Out]("mockIPChecker", "CheckBlacklist", 100)
	return m
}
func (m *mockIPChecker) ResolveAddr(host string) (ret0 net.IP, ret1 error) {
	m.t.Helper()
	m.method.ResolveAddr.In() <- mockIPChecker_ResolveAddr_In{Host: host}
	vegr.PopulateReturns(m.t, m.timeout, m.method.ResolveAddr, &ret0, &ret1)
	return ret0, ret1
}
func (m *mockIPChecker) CheckBlacklist(ip net.IP) (ret0 error) {
	m.t.Helper()
	m.method.CheckBlacklist.In() <- mockIPChecker_CheckBlacklist_In{Ip: ip}
	vegr.PopulateReturns(m.t, m.timeout, m.method.CheckBlacklist, &ret0)
	return ret0
}

// Code generated by git.sr.ht/~nelsam/hel. DO NOT EDIT.
//
// This file contains mocks generated by hel. Do not edit this code by
// hand unless you *really* know what you're doing. Expect any changes
// made manually to be overwritten the next time hel regenerates this
// file.

package v1_test

import (
	"time"

	metrics "code.cloudfoundry.org/go-metric-registry"
	"git.sr.ht/~nelsam/hel/vegr"
	"github.com/cloudfoundry/sonde-go/events"
)

var (
	_ = vegr.EnforceVersion(7 - vegr.MinVersion)
	_ = vegr.EnforceVersion(vegr.MaxVersion - 7)
)

type mockEnvelopeWriter_Write_In struct {
	Event *events.Envelope
}
type mockEnvelopeWriter_Write_Out struct {
	Panic_ any
}
type mockEnvelopeWriter_Write struct {
	vegr.Method[mockEnvelopeWriter_Write_In, mockEnvelopeWriter_Write_Out]
}
type mockEnvelopeWriter struct {
	t       vegr.TestingT
	timeout time.Duration
	method  struct {
		Write mockEnvelopeWriter_Write
	}
}

func newMockEnvelopeWriter(t vegr.TestingT, timeout time.Duration) *mockEnvelopeWriter {
	m := &mockEnvelopeWriter{t: t, timeout: timeout}
	m.method.Write.Method = vegr.NewMethod[mockEnvelopeWriter_Write_In, mockEnvelopeWriter_Write_Out]("mockEnvelopeWriter", "Write", 100)
	return m
}
func (m *mockEnvelopeWriter) Write(event *events.Envelope) {
	m.t.Helper()
	m.method.Write.In() <- mockEnvelopeWriter_Write_In{Event: event}
	vegr.PopulateReturns(m.t, m.timeout, m.method.Write)
}

type mockByteArrayWriter_Write_In struct {
	Message []byte
}
type mockByteArrayWriter_Write_Out struct {
	Panic_ any
}
type mockByteArrayWriter_Write struct {
	vegr.Method[mockByteArrayWriter_Write_In, mockByteArrayWriter_Write_Out]
}
type mockByteArrayWriter struct {
	t       vegr.TestingT
	timeout time.Duration
	method  struct {
		Write mockByteArrayWriter_Write
	}
}

func newMockByteArrayWriter(t vegr.TestingT, timeout time.Duration) *mockByteArrayWriter {
	m := &mockByteArrayWriter{t: t, timeout: timeout}
	m.method.Write.Method = vegr.NewMethod[mockByteArrayWriter_Write_In, mockByteArrayWriter_Write_Out]("mockByteArrayWriter", "Write", 100)
	return m
}
func (m *mockByteArrayWriter) Write(message []byte) {
	m.t.Helper()
	m.method.Write.In() <- mockByteArrayWriter_Write_In{Message: message}
	vegr.PopulateReturns(m.t, m.timeout, m.method.Write)
}

type mockMetricClient_NewCounter_In struct {
	Name, HelpText string
	Opts           []metrics.MetricOption
}
type mockMetricClient_NewCounter_Out struct {
	Panic_ any
	Ret0   metrics.Counter
}
type mockMetricClient_NewCounter struct {
	vegr.Method[mockMetricClient_NewCounter_In, mockMetricClient_NewCounter_Out]
}
type mockMetricClient struct {
	t       vegr.TestingT
	timeout time.Duration
	method  struct {
		NewCounter mockMetricClient_NewCounter
	}
}

func newMockMetricClient(t vegr.TestingT, timeout time.Duration) *mockMetricClient {
	m := &mockMetricClient{t: t, timeout: timeout}
	m.method.NewCounter.Method = vegr.NewMethod[mockMetricClient_NewCounter_In, mockMetricClient_NewCounter_Out]("mockMetricClient", "NewCounter", 100, vegr.Variadic())
	return m
}
func (m *mockMetricClient) NewCounter(name, helpText string, opts ...metrics.MetricOption) (ret0 metrics.Counter) {
	m.t.Helper()
	m.method.NewCounter.In() <- mockMetricClient_NewCounter_In{Name: name, HelpText: helpText, Opts: opts}
	vegr.PopulateReturns(m.t, m.timeout, m.method.NewCounter, &ret0)
	return ret0
}

type mockCounter_Add_In struct {
	Arg0 float64
}
type mockCounter_Add_Out struct {
	Panic_ any
}
type mockCounter_Add struct {
	vegr.Method[mockCounter_Add_In, mockCounter_Add_Out]
}
type mockCounter struct {
	t       vegr.TestingT
	timeout time.Duration
	method  struct {
		Add mockCounter_Add
	}
}

func newMockCounter(t vegr.TestingT, timeout time.Duration) *mockCounter {
	m := &mockCounter{t: t, timeout: timeout}
	m.method.Add.Method = vegr.NewMethod[mockCounter_Add_In, mockCounter_Add_Out]("mockCounter", "Add", 100)
	return m
}
func (m *mockCounter) Add(arg0 float64) {
	m.t.Helper()
	m.method.Add.In() <- mockCounter_Add_In{Arg0: arg0}
	vegr.PopulateReturns(m.t, m.timeout, m.method.Add)
}

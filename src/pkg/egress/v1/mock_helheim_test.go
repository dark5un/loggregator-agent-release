// Code generated by git.sr.ht/~nelsam/hel. DO NOT EDIT.
//
// This file contains mocks generated by hel. Do not edit this code by
// hand unless you *really* know what you're doing. Expect any changes
// made manually to be overwritten the next time hel regenerates this
// file.

package v1_test

import (
	"time"

	metrics "code.cloudfoundry.org/go-metric-registry"
	"git.sr.ht/~nelsam/hel/vegr"
	"github.com/cloudfoundry/sonde-go/events"
)

var (
	_ = vegr.EnforceVersion(7 - vegr.MinVersion)
	_ = vegr.EnforceVersion(vegr.MaxVersion - 7)
)

type mockMetricClient_NewCounter_In struct {
	Name, HelpText string
	Opts           []metrics.MetricOption
}
type mockMetricClient_NewCounter_Out struct {
	Panic_ any
	Ret0   metrics.Counter
}
type mockMetricClient_NewCounter struct {
	vegr.Method[mockMetricClient_NewCounter_In, mockMetricClient_NewCounter_Out]
}
type mockMetricClient struct {
	t       vegr.TestingT
	timeout time.Duration
	method  struct {
		NewCounter mockMetricClient_NewCounter
	}
}

func newMockMetricClient(t vegr.TestingT, timeout time.Duration) *mockMetricClient {
	m := &mockMetricClient{t: t, timeout: timeout}
	m.method.NewCounter.Method = vegr.NewMethod[mockMetricClient_NewCounter_In, mockMetricClient_NewCounter_Out]("mockMetricClient", "NewCounter", 100, vegr.Variadic())
	return m
}
func (m *mockMetricClient) NewCounter(name, helpText string, opts ...metrics.MetricOption) (ret0 metrics.Counter) {
	m.t.Helper()
	m.method.NewCounter.In() <- mockMetricClient_NewCounter_In{Name: name, HelpText: helpText, Opts: opts}
	vegr.PopulateReturns(m.t, m.timeout, m.method.NewCounter, &ret0)
	return ret0
}

type mockBatchChainByteWriter_Write_In struct {
	Message []byte
}
type mockBatchChainByteWriter_Write_Out struct {
	Panic_ any
	Err    error
}
type mockBatchChainByteWriter_Write struct {
	vegr.Method[mockBatchChainByteWriter_Write_In, mockBatchChainByteWriter_Write_Out]
}
type mockBatchChainByteWriter struct {
	t       vegr.TestingT
	timeout time.Duration
	method  struct {
		Write mockBatchChainByteWriter_Write
	}
}

func newMockBatchChainByteWriter(t vegr.TestingT, timeout time.Duration) *mockBatchChainByteWriter {
	m := &mockBatchChainByteWriter{t: t, timeout: timeout}
	m.method.Write.Method = vegr.NewMethod[mockBatchChainByteWriter_Write_In, mockBatchChainByteWriter_Write_Out]("mockBatchChainByteWriter", "Write", 100)
	return m
}
func (m *mockBatchChainByteWriter) Write(message []byte) (err error) {
	m.t.Helper()
	m.method.Write.In() <- mockBatchChainByteWriter_Write_In{Message: message}
	vegr.PopulateReturns(m.t, m.timeout, m.method.Write, &err)
	return err
}

type mockEnvelopeWriter_Write_In struct {
	Event *events.Envelope
}
type mockEnvelopeWriter_Write_Out struct {
	Panic_ any
}
type mockEnvelopeWriter_Write struct {
	vegr.Method[mockEnvelopeWriter_Write_In, mockEnvelopeWriter_Write_Out]
}
type mockEnvelopeWriter struct {
	t       vegr.TestingT
	timeout time.Duration
	method  struct {
		Write mockEnvelopeWriter_Write
	}
}

func newMockEnvelopeWriter(t vegr.TestingT, timeout time.Duration) *mockEnvelopeWriter {
	m := &mockEnvelopeWriter{t: t, timeout: timeout}
	m.method.Write.Method = vegr.NewMethod[mockEnvelopeWriter_Write_In, mockEnvelopeWriter_Write_Out]("mockEnvelopeWriter", "Write", 100)
	return m
}
func (m *mockEnvelopeWriter) Write(event *events.Envelope) {
	m.t.Helper()
	m.method.Write.In() <- mockEnvelopeWriter_Write_In{Event: event}
	vegr.PopulateReturns(m.t, m.timeout, m.method.Write)
}

type mockCounter_Add_In struct {
	Arg0 float64
}
type mockCounter_Add_Out struct {
	Panic_ any
}
type mockCounter_Add struct {
	vegr.Method[mockCounter_Add_In, mockCounter_Add_Out]
}
type mockCounter struct {
	t       vegr.TestingT
	timeout time.Duration
	method  struct {
		Add mockCounter_Add
	}
}

func newMockCounter(t vegr.TestingT, timeout time.Duration) *mockCounter {
	m := &mockCounter{t: t, timeout: timeout}
	m.method.Add.Method = vegr.NewMethod[mockCounter_Add_In, mockCounter_Add_Out]("mockCounter", "Add", 100)
	return m
}
func (m *mockCounter) Add(arg0 float64) {
	m.t.Helper()
	m.method.Add.In() <- mockCounter_Add_In{Arg0: arg0}
	vegr.PopulateReturns(m.t, m.timeout, m.method.Add)
}

type mockEvent_ProtoMessage_In struct {
}
type mockEvent_ProtoMessage_Out struct {
	Panic_ any
}
type mockEvent_ProtoMessage struct {
	vegr.Method[mockEvent_ProtoMessage_In, mockEvent_ProtoMessage_Out]
}
type mockEvent struct {
	t       vegr.TestingT
	timeout time.Duration
	method  struct {
		ProtoMessage mockEvent_ProtoMessage
	}
}

func newMockEvent(t vegr.TestingT, timeout time.Duration) *mockEvent {
	m := &mockEvent{t: t, timeout: timeout}
	m.method.ProtoMessage.Method = vegr.NewMethod[mockEvent_ProtoMessage_In, mockEvent_ProtoMessage_Out]("mockEvent", "ProtoMessage", 100)
	return m
}
func (m *mockEvent) ProtoMessage() {
	m.t.Helper()
	m.method.ProtoMessage.In() <- mockEvent_ProtoMessage_In{}
	vegr.PopulateReturns(m.t, m.timeout, m.method.ProtoMessage)
}

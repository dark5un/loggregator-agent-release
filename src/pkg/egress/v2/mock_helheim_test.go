// Code generated by git.sr.ht/~nelsam/hel. DO NOT EDIT.
//
// This file contains mocks generated by hel. Do not edit this code by
// hand unless you *really* know what you're doing. Expect any changes
// made manually to be overwritten the next time hel regenerates this
// file.

package v2_test

import (
	"time"

	"code.cloudfoundry.org/go-loggregator/v10/rpc/loggregator_v2"
	metrics "code.cloudfoundry.org/go-metric-registry"
	"git.sr.ht/~nelsam/hel/vegr"
)

var (
	_ = vegr.EnforceVersion(7 - vegr.MinVersion)
	_ = vegr.EnforceVersion(vegr.MaxVersion - 7)
)

type mockBatchWriter_Write_In struct {
	Msgs []*loggregator_v2.Envelope
}
type mockBatchWriter_Write_Out struct {
	Panic_ any
	Ret0   error
}
type mockBatchWriter_Write struct {
	vegr.Method[mockBatchWriter_Write_In, mockBatchWriter_Write_Out]
}
type mockBatchWriter struct {
	t       vegr.TestingT
	timeout time.Duration
	method  struct {
		Write mockBatchWriter_Write
	}
}

func newMockBatchWriter(t vegr.TestingT, timeout time.Duration) *mockBatchWriter {
	m := &mockBatchWriter{t: t, timeout: timeout}
	m.method.Write.Method = vegr.NewMethod[mockBatchWriter_Write_In, mockBatchWriter_Write_Out]("mockBatchWriter", "Write", 100)
	return m
}
func (m *mockBatchWriter) Write(msgs []*loggregator_v2.Envelope) (ret0 error) {
	m.t.Helper()
	m.method.Write.In() <- mockBatchWriter_Write_In{Msgs: msgs}
	vegr.PopulateReturns(m.t, m.timeout, m.method.Write, &ret0)
	return ret0
}

type mockEnvelopeProcessor_Process_In struct {
	Arg0 *loggregator_v2.Envelope
}
type mockEnvelopeProcessor_Process_Out struct {
	Panic_ any
	Ret0   error
}
type mockEnvelopeProcessor_Process struct {
	vegr.Method[mockEnvelopeProcessor_Process_In, mockEnvelopeProcessor_Process_Out]
}
type mockEnvelopeProcessor struct {
	t       vegr.TestingT
	timeout time.Duration
	method  struct {
		Process mockEnvelopeProcessor_Process
	}
}

func newMockEnvelopeProcessor(t vegr.TestingT, timeout time.Duration) *mockEnvelopeProcessor {
	m := &mockEnvelopeProcessor{t: t, timeout: timeout}
	m.method.Process.Method = vegr.NewMethod[mockEnvelopeProcessor_Process_In, mockEnvelopeProcessor_Process_Out]("mockEnvelopeProcessor", "Process", 100)
	return m
}
func (m *mockEnvelopeProcessor) Process(arg0 *loggregator_v2.Envelope) (ret0 error) {
	m.t.Helper()
	m.method.Process.In() <- mockEnvelopeProcessor_Process_In{Arg0: arg0}
	vegr.PopulateReturns(m.t, m.timeout, m.method.Process, &ret0)
	return ret0
}

type mockWriter_Write_In struct {
	Arg0 *loggregator_v2.Envelope
}
type mockWriter_Write_Out struct {
	Panic_ any
	Ret0   error
}
type mockWriter_Write struct {
	vegr.Method[mockWriter_Write_In, mockWriter_Write_Out]
}
type mockWriter struct {
	t       vegr.TestingT
	timeout time.Duration
	method  struct {
		Write mockWriter_Write
	}
}

func newMockWriter(t vegr.TestingT, timeout time.Duration) *mockWriter {
	m := &mockWriter{t: t, timeout: timeout}
	m.method.Write.Method = vegr.NewMethod[mockWriter_Write_In, mockWriter_Write_Out]("mockWriter", "Write", 100)
	return m
}
func (m *mockWriter) Write(arg0 *loggregator_v2.Envelope) (ret0 error) {
	m.t.Helper()
	m.method.Write.In() <- mockWriter_Write_In{Arg0: arg0}
	vegr.PopulateReturns(m.t, m.timeout, m.method.Write, &ret0)
	return ret0
}

type mockMetricClient_NewCounter_In struct {
	Name, HelpText string
	Opts           []metrics.MetricOption
}
type mockMetricClient_NewCounter_Out struct {
	Panic_ any
	Ret0   metrics.Counter
}
type mockMetricClient_NewCounter struct {
	vegr.Method[mockMetricClient_NewCounter_In, mockMetricClient_NewCounter_Out]
}
type mockMetricClient struct {
	t       vegr.TestingT
	timeout time.Duration
	method  struct {
		NewCounter mockMetricClient_NewCounter
	}
}

func newMockMetricClient(t vegr.TestingT, timeout time.Duration) *mockMetricClient {
	m := &mockMetricClient{t: t, timeout: timeout}
	m.method.NewCounter.Method = vegr.NewMethod[mockMetricClient_NewCounter_In, mockMetricClient_NewCounter_Out]("mockMetricClient", "NewCounter", 100, vegr.Variadic())
	return m
}
func (m *mockMetricClient) NewCounter(name, helpText string, opts ...metrics.MetricOption) (ret0 metrics.Counter) {
	m.t.Helper()
	m.method.NewCounter.In() <- mockMetricClient_NewCounter_In{Name: name, HelpText: helpText, Opts: opts}
	vegr.PopulateReturns(m.t, m.timeout, m.method.NewCounter, &ret0)
	return ret0
}

type mockNexter_TryNext_In struct {
}
type mockNexter_TryNext_Out struct {
	Panic_ any
	Ret0   *loggregator_v2.Envelope
	Ret1   bool
}
type mockNexter_TryNext struct {
	vegr.Method[mockNexter_TryNext_In, mockNexter_TryNext_Out]
}
type mockNexter struct {
	t       vegr.TestingT
	timeout time.Duration
	method  struct {
		TryNext mockNexter_TryNext
	}
}

func newMockNexter(t vegr.TestingT, timeout time.Duration) *mockNexter {
	m := &mockNexter{t: t, timeout: timeout}
	m.method.TryNext.Method = vegr.NewMethod[mockNexter_TryNext_In, mockNexter_TryNext_Out]("mockNexter", "TryNext", 100)
	return m
}
func (m *mockNexter) TryNext() (ret0 *loggregator_v2.Envelope, ret1 bool) {
	m.t.Helper()
	m.method.TryNext.In() <- mockNexter_TryNext_In{}
	vegr.PopulateReturns(m.t, m.timeout, m.method.TryNext, &ret0, &ret1)
	return ret0, ret1
}

type mockCounter_Add_In struct {
	Arg0 float64
}
type mockCounter_Add_Out struct {
	Panic_ any
}
type mockCounter_Add struct {
	vegr.Method[mockCounter_Add_In, mockCounter_Add_Out]
}
type mockCounter struct {
	t       vegr.TestingT
	timeout time.Duration
	method  struct {
		Add mockCounter_Add
	}
}

func newMockCounter(t vegr.TestingT, timeout time.Duration) *mockCounter {
	m := &mockCounter{t: t, timeout: timeout}
	m.method.Add.Method = vegr.NewMethod[mockCounter_Add_In, mockCounter_Add_Out]("mockCounter", "Add", 100)
	return m
}
func (m *mockCounter) Add(arg0 float64) {
	m.t.Helper()
	m.method.Add.In() <- mockCounter_Add_In{Arg0: arg0}
	vegr.PopulateReturns(m.t, m.timeout, m.method.Add)
}
